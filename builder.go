package main

import (
	"bytes"
	"strings"
	"text/template"
	"time"

	"github.com/gertd/go-pluralize"
	toolsimports "golang.org/x/tools/imports"
)

func createBuilder(pkg *Package) ([]byte, error) {
	funcs := template.FuncMap{
		"fieldType":       fieldType,
		"sliceType":       sliceType,
		"emptyValue":      emptyValue,
		"fieldIsStruct":   fieldIsStruct,
		"getterName":      getterName,
		"canCreateGetter": canCreateGetter,
		"title":           strings.Title,
		"joinString":      strings.Join,
		"now":             func() string { return time.Now().Format(time.RFC3339) },
		"singular":        pluralize.NewClient().Singular,
	}
	t := template.Must(template.New("").Funcs(funcs).Parse(templateData))

	var buf bytes.Buffer

	if err := t.Execute(&buf, pkg); err != nil {
		return nil, err
	}

	if data, err := toolsimports.Process("", buf.Bytes(), nil); err == nil {
		return data, nil
	}

	return buf.Bytes(), nil
}

func fieldType(field Field) (tp string) {
	if field.Slice {
		tp = "[]"
	}

	if field.Pointer {
		tp += "*"
	}

	if field.KindPkg != "" {
		tp += field.KindPkg + "."
	}

	tp += field.KindName
	return
}

func sliceType(field Field) (tp string) {
	if field.Pointer {
		tp = "*"
	}

	if field.KindPkg != "" {
		tp += field.KindPkg + "."
	}

	tp += field.KindName
	return
}

func isBasicType(field Field) bool {
	switch strings.ToLower(field.KindName) {
	case
		"bool",
		"int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
		"float32", "float64",
		"complex64", "complex128",
		"string":
		return field.KindPkg == "" && !field.Slice
	default:
		return false
	}
}
func emptyValue(field Field) (tp string) {
	if field.Pointer {
		return "nil"
	}

	if !isBasicType(field) {
		return fieldType(field) + "{}"
	}

	switch strings.ToLower(field.KindName) {
	case "bool":
		return "false"
	case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "uintptr", "float32", "float64", "complex64", "complex128":
		return "0"
	case "string":
		return `""`
	}

	return "nil"
}

func fieldIsStruct(field Field) bool {
	return !isBasicType(field) && !field.Slice
}

func getterName(field *Field) string {
	return "Get" + field.Name
}

func canCreateGetter(funcs []*StructFunc, stru *Struct, field *Field) bool {
	for _, f := range funcs {
		if f.Struct == stru.Name && f.Name == getterName(field) {
			return false
		}
	}
	return true
}

const templateData = `
// Code generated by go-builder. DO NOT EDIT.
// Source: {{ joinString .FileName ", " }}
// Timestamp: {{ now  }}

package {{.Package}}
{{$funcs := .Funcs}}

{{range $struct := .Structures}}
type {{$struct.Name}}Builder struct {
	{{range $field := $struct.Fields -}}
	x{{$field.Name}} {{fieldType $field}}
	{{end}}
}

func New{{$struct.Name}}Builder() *{{$struct.Name}}Builder {
	return &{{$struct.Name}}Builder{}
}

func New{{$struct.Name}}BuilderFrom(a interface{}) *{{$struct.Name}}Builder {
	var b {{$struct.Name}}Builder
	_ = copier.Copy(&b, a)
	return &b
}

func (b *{{$struct.Name}}Builder) LoadValues(a interface{}) *{{$struct.Name}}Builder {
	_ = copier.Copy(b, a)
	return b
}

{{range $field := $struct.Fields}}
func (b *{{$struct.Name}}Builder) {{$field.Name}}(v {{fieldType $field}}) *{{$struct.Name}}Builder {
	b.x{{$field.Name}} = v
	return b
}

{{if fieldIsStruct $field}}
func (b *{{$struct.Name}}Builder) {{$field.Name}}Func(f func({{fieldType $field}}) {{fieldType $field}}) *{{$struct.Name}}Builder {
	b.x{{$field.Name}} = f(b.x{{$field.Name}})
	return b
}
{{end}}

{{if $field.Slice}}
func (b *{{$struct.Name}}Builder) Clear{{$field.Name | title}}() *{{$struct.Name}}Builder {
	b.x{{$field.Name}} = {{emptyValue $field}}
	return b
}

func (b *{{$struct.Name}}Builder) Add{{$field.Name | singular | title}}(value {{sliceType $field}}) *{{$struct.Name}}Builder {
	b.x{{$field.Name}} = append(b.x{{$field.Name}}, value)
	return b
}

func (b *{{$struct.Name}}Builder) ForEach{{$field.Name | singular | title}}(f func({{sliceType $field}}) {{sliceType $field}}) *{{$struct.Name}}Builder {
	list := make({{fieldType $field}}, 0, len(b.x{{$field.Name}}))
	for _, item := range b.x{{$field.Name}} {
		list = append(list, f(item))
	}
	b.x{{$field.Name}} = list
	return b
}
{{end}}

{{end}}

func (b *{{$struct.Name}}Builder) Build() *{{$struct.Name}} {
	return &{{$struct.Name}}{
		{{range $field := $struct.Fields -}}
		{{$field.Name}}: b.x{{$field.Name}},
		{{end}}
	}
}

func (a *{{$struct.Name}}) ToBuilder() *{{$struct.Name}}Builder {
	return &{{$struct.Name}}Builder{
		{{range $field := $struct.Fields -}}
		x{{$field.Name}}: a.{{$field.Name}},
		{{end}}
	}
}

{{range $field := $struct.Fields}}
{{if canCreateGetter $funcs $struct $field}}
func (a *{{$struct.Name}}) {{$field | getterName}}() {{fieldType $field}} {
	if a == nil {
		return {{emptyValue $field}}
	}
	return a.{{$field.Name}}
}
{{end}}
{{end}}
{{end}}
`
